<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sealed in Rust — Domain-Driven Edition</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="The example book covers examples.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Sealed in Rust — Domain-Driven Edition</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/mdBook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>Cryptography is everywhere — and yet most of us treat it like magic.</strong></p>
<p>From encrypted chats and online banking to firmware updates on satellites, the systems we rely on daily are secured (or compromised) by cryptography. And too often, it fails — not because the math was wrong, but because the implementation was.</p>
<p><strong>This book exists to change that.</strong></p>
<p>You’re not here to memorize equations. You’re here to understand, implement, and apply cryptographic primitives to real-world systems using a language designed to prevent mistakes before they happen: <strong>Rust</strong>.</p>
<p>Whether you’re building infrastructure, smart contracts, embedded firmware, or secure APIs, this book gives you the tools to use cryptography safely, idiomatically, and fearlessly — one primitive, one project, one domain at a time.</p>
<h2 id="who-this-book-is-for"><a class="header" href="#who-this-book-is-for">Who This Book Is For</a></h2>
<ul>
<li>Rust developers who want to understand and apply cryptography</li>
<li>Security engineers transitioning to Rust</li>
<li>Curious hackers tired of black-box crypto</li>
<li>Systems developers who care about safety, correctness, and resilience</li>
</ul>
<h2 id="what-youll-learn"><a class="header" href="#what-youll-learn">What You’ll Learn</a></h2>
<ul>
<li>The foundations and mental models behind symmetric and asymmetric cryptography</li>
<li>How to use modern cryptographic crates in Rust safely and idiomatically</li>
<li>Where cryptographic primitives show up in real-world domains (blockchain, embedded, medical, etc.)</li>
<li>How to design, test, and publish your own secure Rust crypto crate</li>
</ul>
<h2 id="what-this-book-is-not"><a class="header" href="#what-this-book-is-not">What This Book Is Not</a></h2>
<ul>
<li>❌ A math-heavy cryptography textbook</li>
<li>❌ A copy-paste cookbook</li>
<li>❌ A blockchain hype manual</li>
</ul>
<p>We won’t drown you in proofs, but we’ll explain just enough math to build intuition. We’ll write real code — not just use libraries. And we’ll focus on systems-level crypto, not speculative tokens.</p>
<h2 id="what-youll-need"><a class="header" href="#what-youll-need">What You’ll Need</a></h2>
<ul>
<li>✅ Basic experience with Rust (enough to build a CLI or follow <code>cargo run</code>)</li>
<li>✅ Comfort with reading code, refactoring, and using crates</li>
<li>✅ Curiosity, and a bias toward safe, practical, applied learning</li>
</ul>
<h2 id="lets-begin"><a class="header" href="#lets-begin">Let’s begin</a></h2>
<p>This book won’t make you a cryptographer in the academic sense — but it will make you something just as rare and valuable:
A Rust engineer who understands, wields, and applies cryptography with precision, context, and confidence.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to Use This Book</a></h1>
<p>This book is designed to be practical, modular, and domain-focused.<br />
You can read it front to back, or jump directly to the domains and primitives most relevant to your work.</p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>The book is organized into four major parts:</p>
<p><strong>Foundations</strong> — Why Rust is uniquely suited for secure cryptographic engineering<br />
<strong>Primitives</strong> — The core building blocks of cryptography, with Rust-focused usage and implementation<br />
<strong>Applied Domains</strong> — Real-world systems and how they use cryptography in practice (blockchain, defense, aerospace, medical, infrastructure, etc.)<br />
<strong>Crate Building</strong> — How to architect, test, audit, and publish your own cryptographic crate in Rust</p>
<h3 id=""><a class="header" href="#"></a></h3>
<p>Each chapter includes:</p>
<ul>
<li>Plain-language explanations</li>
<li>Rust code examples using community crates</li>
<li>Security insights and common pitfalls</li>
<li>Domain-specific applications</li>
</ul>
<h2 id="code-and-examples"><a class="header" href="#code-and-examples">Code and Examples</a></h2>
<p>Most chapters include runnable Rust code to illustrate key concepts.</p>
<ul>
<li>You’ll need a working Rust toolchain (<code>rustup</code>, <code>cargo</code>)</li>
<li>Code examples are written for Rust 2021 edition</li>
</ul>
<!--- All examples are hosted in [a separate repository](https://github.com/VinEckSie/sealed-in-rust-examples)-->
<p>Each folder in that repo corresponds to a chapter or concept from the book.<br />
You can clone it, run the examples, and experiment freely without touching production code or complex crates.</p>
<blockquote>
<p><strong>Note:</strong> These examples are minimal and didactic. They are not full cryptographic libraries.</p>
</blockquote>
<!--If you're looking for a complete, idiomatic crypto crate, see my separate library: [Cryon](https://github.com/VinEckSie/cryon)-->
<h2 id="non-linear-reading"><a class="header" href="#non-linear-reading">Non-linear Reading</a></h2>
<p>This book doesn’t assume linear progress.</p>
<ul>
<li>Want to build a secure file encryption tool? <strong>Symmetric Ciphers</strong> + <strong>Secure Infrastructure</strong></li>
<li>Curious about smart contracts? Go directly to <strong>ECC</strong> and <strong>Blockchain &amp; Web3</strong></li>
<li>Working on embedded firmware? Check out <strong>Ascon</strong>, <strong>PRESENT</strong>, and <strong>Defense &amp; Aerospace</strong></li>
</ul>
<p>Each domain chapter reminds you of the necessary primitives — like a map, not a locked path.</p>
<h2 id="contributing-feedback--issues"><a class="header" href="#contributing-feedback--issues">Contributing, Feedback, &amp; Issues</a></h2>
<p>This book is a living project.</p>
<ul>
<li>Errors? Open an issue or PR on the <a href="https://github.com/VinEckSie/sealed-in-rust">GitHub repo</a></li>
<li>Suggestions? You’re welcome to share ideas for domains, examples, or improvements</li>
<li>Contributions to the examples repo are also welcome</li>
</ul>
<h2 id="final-note"><a class="header" href="#final-note">Final Note</a></h2>
<p>This is not a cryptography textbook — it’s a cryptographic engineering manual.<br />
By the end, you’ll not only understand the primitives, you’ll know how to use them to secure real systems — in Rust, by design, not by accident.</p>
<p>Let’s begin.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cryptography-is-a-systems-problem"><a class="header" href="#cryptography-is-a-systems-problem">Cryptography is a Systems Problem</a></h2>
<p>Cryptography isn’t just about math.</p>
<p>Yes, it starts with elegant algebra and deep number theory — but where it breaks is almost always <em>in the system</em>. Real-world failures come from poor implementations, leaky abstractions, memory bugs, side channels, or simply misunderstanding what problem crypto is supposed to solve.</p>
<p>It’s easy to misuse even “secure” primitives. AES<sup class="footnote-reference" id="fr-aes-1"><a href="#footnote-aes">1</a></sup> in ECB mode<sup class="footnote-reference" id="fr-ecb-1"><a href="#footnote-ecb">2</a></sup> is fast — and useless. RSA<sup class="footnote-reference" id="fr-rsa-1"><a href="#footnote-rsa">3</a></sup> without padding<sup class="footnote-reference" id="fr-padding-1"><a href="#footnote-padding">4</a></sup> is a gift to attackers. And a perfectly strong key means nothing if it’s printed to your logs.</p>
<p>This is why cryptography is a <strong>systems engineering problem</strong> first.</p>
<p>And it’s why Rust matters.</p>
<p>Rust doesn’t make crypto correct by default — nothing does — but it gives you tools to <strong>avoid entire classes of catastrophic bugs</strong>.</p>
<p>Memory safety, explicit ownership, fearless concurrency, and tight control over the machine — these aren’t “nice to have.” They’re security features.</p>
<h3 id="-1"><a class="header" href="#-1"></a></h3>
<p>In this book, we’ll treat crypto not as a black box, but as a series of concrete systems problems — and show how Rust lets us solve them with clarity and precision.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-aes">
<p>AES (Advanced Encryption Standard) is a widely used symmetric cipher known for its performance and strong security — when used correctly. <a href="#fr-aes-1">↩</a></p>
</li>
<li id="footnote-ecb">
<p>ECB (Electronic Code Book) mode encrypts each block independently, revealing patterns in the plaintext and making it insecure for most purposes. <a href="#fr-ecb-1">↩</a></p>
</li>
<li id="footnote-rsa">
<p>RSA (Rivest–Shamir–Adleman) is a public-key cryptosystem used for encryption and digital signatures. It relies on the difficulty of factoring large integers. <a href="#fr-rsa-1">↩</a></p>
</li>
<li id="footnote-padding">
<p>Padding in RSA adds randomness or structure to the plaintext before encryption, preventing deterministic outputs. Without it, attackers can guess messages, detect patterns, or exploit mathematical properties to break the cipher. <a href="#fr-padding-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="safety-performance-predictability"><a class="header" href="#safety-performance-predictability">Safety, Performance, Predictability</a></h2>
<p>Rust is often praised for its speed and memory safety, but in the world of cryptographic engineering, these traits aren’t just nice-to-haves — they’re critical.</p>
<h3 id="safety"><a class="header" href="#safety">Safety</a></h3>
<p>Bugs in cryptographic code can be catastrophic. Memory corruption, undefined behavior, or uninitialized values can leak secrets or open attack vectors. Rust eliminates entire classes of these bugs at compile time:</p>
<ul>
<li>No nulls</li>
<li>No uninitialized memory</li>
<li>No data races</li>
<li>No buffer overflows</li>
</ul>
<p>This safety isn’t enforced by a runtime, but by the <strong>borrow checker</strong> at compile time. That makes Rust extremely attractive for writing low-level cryptographic code <strong>without sacrificing control</strong>.</p>
<h3 id="performance"><a class="header" href="#performance">️Performance</a></h3>
<p>Rust compiles to fast native code, comparable to C and C++. There’s no garbage collector, and you pay only for what you use. This matters because cryptography is often used in:</p>
<ul>
<li>Performance-critical code paths (e.g. TLS handshakes, file encryption)</li>
<li>Embedded systems where CPU cycles and memory are limited</li>
</ul>
<p>Rust lets you stay close to the metal while writing high-level abstractions — it’s a rare balance.</p>
<h3 id="predictability"><a class="header" href="#predictability">Predictability</a></h3>
<p>In cryptography, <strong>predictable behavior</strong> is essential. You need fine-grained control over:</p>
<ul>
<li><strong>Timing</strong> — Avoid accidental leaks via early-exit comparisons or branching on secrets</li>
<li><strong>Memory</strong> — Prevent unexpected reallocations or optimization side effects</li>
<li><strong>Execution</strong> — Ensure constant-time logic without interference from JITs or hidden runtime behavior</li>
</ul>
<p>Rust gives you this control by default, making it a strong ally in defending against side-channel attacks.</p>
<blockquote>
<p>In short: Rust brings the low-level control of C, the safety of functional languages, and the clarity of modern syntax — all in a single toolchain. That’s why cryptographers and security engineers are increasingly turning to it.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-cost-of-unsafety-in-crypto-famous-failures"><a class="header" href="#the-cost-of-unsafety-in-crypto-famous-failures">The Cost of Unsafety in Crypto: Famous Failures</a></h2>
<p>Cryptography doesn’t fail because math is broken — it fails because <strong>systems leak</strong>, <strong>code panics</strong>, or <strong>side-channels whisper secrets</strong>.<br><br>
And most of these failures? They stem from unsafety.
<br><br><br>
Here are just a few real-world examples of cryptographic disasters caused by unsafe programming, undefined behavior, or lack of control:</p>
<h4 id="heartbleed-2014"><a class="header" href="#heartbleed-2014">Heartbleed (2014)</a></h4>
<ul>
<li><strong>Cause:</strong> Buffer over-read in OpenSSL (written in C)</li>
<li><strong>Impact:</strong> Leaked private keys, passwords, and session data from millions of servers</li>
<li><strong>Lesson:</strong> Unsafe memory access can silently expose secrets</li>
</ul>
<h4 id="debian-rng-bug-20062008"><a class="header" href="#debian-rng-bug-20062008">Debian RNG Bug (2006–2008)</a></h4>
<ul>
<li><strong>Cause:</strong> A developer commented out entropy-gathering code in OpenSSL</li>
<li><strong>Impact:</strong> Generated only 32,768 possible SSH keys across all Debian systems</li>
<li><strong>Lesson:</strong> Cryptographic quality often hinges on <strong>deterministic, auditable behavior</strong></li>
</ul>
<h4 id="lucky13-attack-2013"><a class="header" href="#lucky13-attack-2013">Lucky13 Attack (2013)</a></h4>
<ul>
<li><strong>Cause:</strong> Tiny timing differences in CBC mode padding checks (TLS)</li>
<li><strong>Impact:</strong> Allowed attackers to decrypt data by measuring how long responses took</li>
<li><strong>Lesson:</strong> Timing leaks can <strong>invalidate encryption</strong>, even with perfect math</li>
</ul>
<h4 id="javascript-crypto-fails"><a class="header" href="#javascript-crypto-fails">JavaScript Crypto Fails</a></h4>
<ul>
<li><strong>Cause:</strong> Misuse of <code>Math.random()</code> or insecure key handling in frontend apps</li>
<li><strong>Impact:</strong> Predictable keys, insecure password storage, and non-constant-time comparisons</li>
<li><strong>Lesson:</strong> Languages with hidden optimizations make <strong>constant-time logic fragile</strong></li>
</ul>
<h3 id="why-rust-helps"><a class="header" href="#why-rust-helps">Why Rust Helps</a></h3>
<p>Rust’s safety model eliminates whole classes of vulnerabilities:</p>
<ul>
<li>No null/dangling pointers</li>
<li>No uninitialized memory</li>
<li>Memory-safe concurrency</li>
<li>Deterministic behavior at runtime (no GC pauses, no JIT surprise)</li>
</ul>
<p>You still have to <strong>design crypto carefully</strong>, but with Rust, you’re not building it on quicksand.</p>
<blockquote>
<p>Writing secure cryptography in unsafe languages is like writing legal contracts with disappearing ink.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="first-code-a-naive-xor-encryptor"><a class="header" href="#first-code-a-naive-xor-encryptor">First Code: A Naive XOR Encryptor</a></h2>
<p>Let’s write our first cryptographic algorithm — or at least something that <em>looks</em> like one.</p>
<p>We’ll implement a simple <strong>XOR cipher</strong>. This method is <em>insecure</em> and should never be used in real applications — but it’s the perfect teaching tool.</p>
<h3 id="whats-a-cipher"><a class="header" href="#whats-a-cipher">What’s a Cipher?</a></h3>
<p>A <strong>cipher</strong> is just a method to <strong>transform readable data (plaintext)</strong> into <strong>unreadable data (ciphertext)</strong> using a <strong>key</strong> — and vice versa.</p>
<blockquote>
<p>🧭 Word Origin — “Cipher”
The word comes from the Arabic “ṣifr” (صفر), meaning “zero” or “empty”. It passed through Latin (cifra), then into French and English as cipher.<br><br>
What started as a symbol for “nothing” evolved into a word for secret writing — and eventually, encryption algorithms.</p>
</blockquote>
<h3 id="what-is-xor"><a class="header" href="#what-is-xor">What is XOR?</a></h3>
<p>XOR stands for <strong>“exclusive or”</strong>, a bitwise operation:</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>B</th><th>A XOR B</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>0</td></tr>
</tbody></table>
</div>
<p>In short: XOR returns 1 if the bits differ, 0 if they’re the same.</p>
<p>The XOR operation flips bits when they differ:</p>
<pre><code class="language-text">1 ^ 0 = 1
1 ^ 1 = 0
0 ^ 0 = 0
</code></pre>
<p>When used for encryption:</p>
<pre><code class="language-text">cipher = plaintext ^ key
plaintext = cipher ^ key
</code></pre>
<p>That’s why XOR can be used to encrypt and decrypt data — if you XOR something twice with the same key, you get the original back.</p>
<blockquote>
<p>✅ Simple, reversible, fast — but also dangerously weak when misused.</p>
</blockquote>
<h3 id="xor-bit-by-bit"><a class="header" href="#xor-bit-by-bit">XOR, Bit by Bit</a></h3>
<p>To truly understand XOR in cryptography, it helps to look at bit-level behavior.</p>
<p>Let’s say you compute:</p>
<pre><code class="language-rust noplayground">100 ^ 1</code></pre>
<p>This doesn’t mean 100 to the power of 1. In Rust, ^ is the bitwise XOR operator.</p>
<p>Step-by-step:</p>
<pre><code class="language-yaml">100 = 0110 0100
1   = 0000 0001
---------------
XOR = 0110 0101 = 101
</code></pre>
<p>✅ Each bit is compared:
If they’re different → 1
If they’re the same → 0</p>
<pre><code class="language-rust noplayground">100 ^ 1 = 101</code></pre>
<p>This is what makes XOR useful: you can toggle bits with a key, and reverse it by applying the same key again.</p>
<h3 id="why-this"><a class="header" href="#why-this">Why This?</a></h3>
<p>This example teaches you:</p>
<ul>
<li>The reversible nature of XOR (<code>a ^ b ^ b == a</code>)</li>
<li>Handling bytes and slices in Rust</li>
<li>Thinking about encryption as a transformation</li>
<li>Why key reuse and simplicity are dangerous</li>
</ul>
<h3 id="naive-xor-in-rust"><a class="header" href="#naive-xor-in-rust">Naive XOR in Rust</a></h3>
<p>Here’s how to implement a basic XOR encryptor in Rust: <br></p>
<p>Filename: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let message = b"hello world";
    let key = b"key";

    let encrypted = xor_encrypt(message, key);
    let decrypted = xor_encrypt(&amp;encrypted, key);

    println!("Encrypted: {:x?}", encrypted);
    println!("Decrypted: {}", String::from_utf8_lossy(&amp;decrypted));
}

pub fn xor_encrypt(input: &amp;[u8], key: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    input
        .iter()
        .enumerate()
        .map(|(i, &amp;byte)| byte ^ key[i % key.len()])
        .collect()
}</code></pre></pre>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<p>The output will show the encrypted bytes (in hex) and the original decrypted message.</p>
<h3 id="whats-wrong-with-this-cipher"><a class="header" href="#whats-wrong-with-this-cipher">What’s Wrong With This Cipher?</a></h3>
<ul>
<li>Key reuse makes patterns obvious</li>
<li>No randomness or initialization vector (IV)</li>
<li>Susceptible to frequency analysis attacks</li>
</ul>
<br>
This cipher is insecure — but it demonstrates important cryptographic concepts:
<ul>
<li>Reversibility</li>
<li>Byte-wise transformations</li>
<li>Why randomness and key handling matter</li>
</ul>
<p>You’ll build on this when implementing real-world ciphers like ChaCha20 or AES.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tooling-up"><a class="header" href="#tooling-up">Tooling Up</a></h2>
<p>Before we dive into cryptographic primitives, here’s a quick look at tools that can support your Rust development journey — especially if you plan to write your own crypto libraries.</p>
<blockquote>
<p>None of these tools are required to read or complete the following chapters.<br />
If you already have <code>cargo</code> installed, you’re good to go!</p>
</blockquote>
<p>That said, for readers who want to build clean, secure, and testable codebases, these tools are worth bookmarking:</p>
<h3 id="code-quality"><a class="header" href="#code-quality">Code Quality</a></h3>
<ul>
<li><strong><a href="https://github.com/rust-lang/rustfmt">rustfmt</a></strong> — auto-formats code to keep it idiomatic</li>
<li><strong><a href="https://github.com/rust-lang/rust-clippy">clippy</a></strong> — catches common pitfalls and non-idiomatic patterns</li>
</ul>
<h3 id="testing--fuzzing"><a class="header" href="#testing--fuzzing">Testing &amp; Fuzzing</a></h3>
<ul>
<li><strong><a href="https://docs.rs/proptest">proptest</a></strong> — property-based testing for edge case discovery</li>
<li><strong><a href="https://rust-fuzz.github.io/book/">cargo-fuzz</a></strong> — fuzz testing to uncover panics and vulnerabilities</li>
</ul>
<h3 id="security--auditing"><a class="header" href="#security--auditing">Security &amp; Auditing</a></h3>
<ul>
<li><strong><a href="https://github.com/RustSec/rustsec/tree/main/cargo-audit">cargo-audit</a></strong> — alerts you to vulnerable crates</li>
<li><strong><a href="https://github.com/rust-secure-code/cargo-geiger">cargo-geiger</a></strong> — scans for <code>unsafe</code> code</li>
</ul>
<h3 id="benchmarking--debugging"><a class="header" href="#benchmarking--debugging">Benchmarking &amp; Debugging</a></h3>
<ul>
<li><strong><a href="https://bheisler.github.io/criterion.rs/book/">Criterion.rs</a></strong> — precise performance benchmarks</li>
<li><strong><a href="https://github.com/dtolnay/cargo-expand">cargo-expand</a></strong> — view macro-expanded code (useful when using <code>#[derive(...)]</code>)</li>
</ul>
<p>As you gain experience, integrating these tools will help ensure your cryptographic code is not only correct — but robust, maintainable, and audit-friendly.</p>
<h3 id="try-it-yourself"><a class="header" href="#try-it-yourself">Try It Yourself</a></h3>
<p>Want to skip the setup and jump right into coding?</p>
<p>👉 Use the <a href="https://github.com/vinecksie/sealed-starter">Sealed in Rust Starter Template</a> — a minimal Rust project preconfigured with the tools mentioned above.</p>
<pre><code class="language-bash">git clone https://github.com/vinecksie/sealed-starter.git
cd sealed-starter
cargo test
</code></pre>
<!--This project will evolve with the book and include examples, tests, and benchmarking code as you progress.--><div style="break-before: page; page-break-before: always;"></div><h2 id="symmetric-ciphers-xor-aes-chacha20--beyond"><a class="header" href="#symmetric-ciphers-xor-aes-chacha20--beyond">Symmetric Ciphers: XOR, AES, ChaCha20 &amp; Beyond</a></h2>
<blockquote>
<p>🔐 <strong>Used in:</strong> VPNs, TLS (post-handshake), disk encryption, messaging apps<br />
✅ Still foundational in modern cryptography.</p>
</blockquote>
<h3 id="what-are-symmetric-ciphers"><a class="header" href="#what-are-symmetric-ciphers">What Are Symmetric Ciphers?</a></h3>
<p>Symmetric ciphers use the <strong>same key</strong> for both encryption and decryption. Unlike public-key cryptography, they don’t offer key exchange—but they are <strong>much faster</strong>, making them ideal for bulk data encryption.</p>
<p>They are used everywhere: encrypted file systems, secure communications, and even inside protocols like TLS (after the handshake).</p>
<h3 id="xor-cipher--simplicity-that-teaches"><a class="header" href="#xor-cipher--simplicity-that-teaches">XOR Cipher — Simplicity That Teaches</a></h3>
<blockquote>
<p>⚠️ Insecure. Demonstration-only (used in educational demos, malware obfuscation )</p>
</blockquote>
<p><img src="https://github.com/user-attachments/assets/e6eeacfc-ba92-4ecf-bb7b-48ad2384c1ae" alt="youtube" />   Watch it on my <em>Fearless in Rust</em> channel:  <a href="https://www.youtube.com/watch?v=wA-p_c19ZFw&amp;t=326s">XOR Cipher in Rust - Step by Step</a></p>
<!--
>⚠️ Annotate if a Rust crate exists + maturity level
-->
<p>We first explored XOR encryption in <a href="02-core-primitives/../01-foundations/01-04-first-code.html">Section 1.4: First Code — A Naive XOR Encryptor</a>, where we built a full working example from scratch.</p>
<p>XOR is the simplest symmetric cipher: each byte of the message is XORed with a repeating key.
Reversibility is built-in — XORing twice with the same key restores the original.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let message = b"Hi, Rust!";
    let key = b"key";

    let encrypted = xor_encrypt(message, key);
    let decrypted = xor_encrypt(&amp;encrypted, key);

    println!("Encrypted: {:x?}", encrypted);
    println!("Decrypted: {}", String::from_utf8_lossy(&amp;decrypted));
}

pub fn xor_encrypt(input: &amp;[u8], key: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    input
        .iter()
        .enumerate()
        .map(|(i, &amp;byte)| byte ^ key[i % key.len()])
        .collect()
}</code></pre></pre>
<blockquote>
<p><strong>🟢 Conclusion</strong>
XOR encryption is reversible and stateless, which makes it simple and fast. But it lacks confusion and diffusion, so patterns in the input remain visible — offering no real resistance to cryptanalysis.</p>
</blockquote>
<h3 id="feistel-networks--foundation-of-classic-block-ciphers"><a class="header" href="#feistel-networks--foundation-of-classic-block-ciphers">Feistel Networks — Foundation of Classic Block Ciphers</a></h3>
<blockquote>
<p>⚠️ Cryptographically obsolete, but conceptually important (used in DES, 3DES)</p>
</blockquote>
<!--
> ⚠️️ Annotate if a Rust crate exists + maturity level
-->
<p>Feistel networks are a clever way to build reversible encryption using any basic function—even if that function itself can’t be reversed. That’s the key idea.</p>
<p>Each round applies a transformation to the data. Multiple rounds are chained to strengthen security.</p>
<p>Each round does the following:</p>
<ol>
<li>Takes two halves: Left (L) and Right (R)</li>
<li>Computes a function f(R, key)</li>
<li>Updates the pair as:</li>
</ol>
<pre><code class="language-vbnet">L₂ = R₁
R₂ = L₁ ⊕ f(R₁, key)
</code></pre>
<p>To encrypt, let’s see it in Rust:</p>
<pre><pre class="playground"><code class="language-rust">fn feistel_round(l: u8, r: u8, k: u8) -&gt; (u8, u8) {
    let f = r ^ k;
    (r, l ^ f)
}

fn main() {
    let left1: u8 = 0b1010_1010;  // 170
    let right1: u8 = 0b0101_0101; // 85
    let key: u8 = 0b1111_0000;   // 240

    let (left2, right2) = feistel_round(left1, right1, key);
    println!("Encrypted: ({}, {})", left2, right2);
}</code></pre></pre>
<p>Decryption reuses the same function f, simply reversing the round transformation:</p>
<pre><pre class="playground"><code class="language-rust">fn feistel_round(l1: u8, r1: u8, k: u8) -&gt; (u8, u8) {
    let f = r1 ^ k;
    (r1, l1 ^ f)
}

fn feistel_decrypt(l2: u8, r2: u8, k: u8) -&gt; (u8, u8) {
    let f = l2 ^ k;
    let l1 = r2 ^ f;
    (l1, l2)
}

fn main() {
    let left1: u8 = 0b1010_1010;  // 170
    let right1: u8 = 0b0101_0101; // 85
    let key: u8 = 0b1111_0000;   // 240

    let (left2, right2) = feistel_round(left1, right1, key);
    println!("Encrypted: ({}, {})", left2, right2);

    let (left_orig, right_orig) = feistel_decrypt(left2, right2, key);
    println!("Decrypted: ({}, {})", left_orig, right_orig);
}</code></pre></pre>
<br>
Because encryption produces :
<pre><code class="language-pgsql">Encrypted → (R, L ⊕ f(R, k))
</code></pre>
<p>Let’s define:</p>
<ul>
<li>L₁ and R₁ = original input</li>
<li>L₂ = R₁ and R₂ = L₁ ⊕ f(R₁, k)</li>
</ul>
<p>We receive (L₂, R₂) and want to recover (L₁, R₁):</p>
<ol>
<li>
<p>From encryption, we know L₂ = R₁</p>
<ul>
<li>So: R₁ = L₂</li>
</ul>
</li>
<li>
<p>And: R₂ = L₁ ⊕ f(R₁, k)</p>
<ul>
<li>Replace R₁ with L₂</li>
<li>R₂ = L₁ ⊕ f(L₂, k)</li>
</ul>
</li>
<li>
<p>Rearranging to get L₁:</p>
<ul>
<li>L₁ = R₂ ⊕ f(L₂, k)</li>
</ul>
</li>
</ol>
<br>
So, decryption is
<pre><code class="language-pgsql">L₁ = R₂ ⊕ f(L₂, k)
R₁ = L₂
</code></pre>
<blockquote>
<p><strong>🟢 Conclusion</strong><br />
Reversibility comes from XOR being reversible and swapping the halves.
Feistel networks let you build reversible encryption even with non-invertible functions.
This idea shaped DES and similar ciphers.</p>
<p>Not used today due to known vulnerabilities, but conceptually essential.</p>
</blockquote>
<h3 id="substitutionpermutation-networks-spn"><a class="header" href="#substitutionpermutation-networks-spn">Substitution–Permutation Networks (SPN)</a></h3>
<blockquote>
<p>⚠️ Used in AES, Camellia, and modern block ciphers.
Still dominant in current cipher architectures</p>
</blockquote>
<!--
> ⚠️ Annotate if a Rust crate exists + maturity level
-->
<p>Substitution-Permutation Networks (SPNs) are a powerful way to build secure block ciphers by layering simple operations repeated across multiple rounds to build a secure cipher.</p>
<p>Each round does the following:</p>
<ol>
<li>Substitution – replace each byte using an S-box (non-linear mapping)</li>
<li>Permutation – reorder bits or bytes to spread influence</li>
<li>Key mixing – XOR the block with a round key</li>
</ol>
<p>Decryption reverses these steps in reverse order.</p>
<blockquote>
<p>💡 An S-box (substitution box) is a predefined table that maps each input byte to a new output byte.
Its goal is to introduce non-linearity — meaning the output doesn’t follow any simple, predictable rule based on the input.
<br><br>
This non-linear mapping ensures that small changes in the input produce unpredictable changes in the output, making it impossible to reverse or model with linear equations — a key requirement for secure encryption.</p>
</blockquote>
<br>
Let’s walk through a simple encryption of a 4-byte block.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::TryInto;

// Manually defined "shuffled" S-box (shortened for demo)
let s_box: [u8; 16] = [
   0x63, 0x7C, 0x77, 0x7B,
   0xF2, 0x6B, 0x6F, 0xC5,
   0x30, 0x01, 0x67, 0x2B,
   0xFE, 0xD7, 0xAB, 0x76,
];

// Step 1: Substitution with S-box
// ⚠️ input and output (substituted) must have the same size
// Otherwise, map() or indexing will panic at runtime
let input: [u8; 4] = [0x00, 0x03, 0x07, 0x0F];
let substituted: [u8; 4] = input.map(|b| s_box[b as usize]);

// Step 2: Permutation (custom byte reordering)
let permuted: [u8; 4] = [
   substituted[2], // byte 2 moves to pos 0
   substituted[0], // byte 0 → pos 1
   substituted[3], // byte 3 → pos 2
   substituted[1], // byte 1 → pos 3
];

// Step 3: XOR with round key
let round_key: [u8; 4] = [0xF0, 0x0F, 0xAA, 0x55];
let encrypted: [u8; 4] = permuted
   .iter()
   .zip(round_key.iter())
   .map(|(a, b)| a ^ b)
   .collect::&lt;Vec&lt;u8&gt;&gt;()
   .try_into()
   .unwrap();


println!("Step        | Byte 0 | Byte 1 | Byte 2 | Byte 3");
println!("------------|--------|--------|--------|--------");
println!("Input       | {:02X}     | {:02X}     | {:02X}     | {:02X}", input[0], input[1], input[2], input[3]);
println!("Substituted | {:02X}     | {:02X}     | {:02X}     | {:02X}", substituted[0], substituted[1], substituted[2], substituted[3]);
println!("Permuted    | {:02X}     | {:02X}     | {:02X}     | {:02X}", permuted[0], permuted[1], permuted[2], permuted[3]);
println!("Encrypted   | {:02X}     | {:02X}     | {:02X}     | {:02X}", encrypted[0], encrypted[1], encrypted[2], encrypted[3]);
<span class="boring">}</span></code></pre></pre>
<br>
To decrypt, reverse the steps in reverse order:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::TryInto;

// Same S-box used for encryption
let s_box: [u8; 16] = [
   0x63, 0x7C, 0x77, 0x7B,
   0xF2, 0x6B, 0x6F, 0xC5,
   0x30, 0x01, 0x67, 0x2B,
   0xFE, 0xD7, 0xAB, 0x76,
];

// Generate inverse S-box
let mut inverse_s_box = [0u8; 256];
for (i, &amp;val) in s_box.iter().enumerate() {
   inverse_s_box[val as usize] = i as u8;
}

// Encrypted block from the previous encryption output
let encrypted: [u8; 4] = [0x35, 0x6C, 0xDC, 0x2E];
let round_key: [u8; 4] = [0xF0, 0x0F, 0xAA, 0x55];

// Step 1: Undo XOR with round key
let xor_reversed: [u8; 4] = encrypted
        .iter()
        .zip(round_key.iter())
        .map(|(a, b)| a ^ b)
        .collect::&lt;Vec&lt;u8&gt;&gt;()
        .try_into()
        .unwrap();

// Step 2:  Reverse permutation
// Remember: original permutation was [2, 0, 3, 1]
// So now we must do: [1, 3, 0, 2]
let permuted_reversed: [u8; 4] = [
   xor_reversed[1], // was originally at index 0
   xor_reversed[3], // was at index 1
   xor_reversed[0], // was at index 2
   xor_reversed[2], // was at index 3
];

// Step 3: Inverse substitution using inverse_s_box
let decrypted: [u8; 4] = permuted_reversed.map(|b| inverse_s_box[b as usize]);


println!("Step        | Byte 0 | Byte 1 | Byte 2 | Byte 3");
println!("------------|--------|--------|--------|--------");
println!("Encrypted   | {:02X}     | {:02X}     | {:02X}     | {:02X}", encrypted[0], encrypted[1], encrypted[2], encrypted[3]);
println!("XOR Rev     | {:02X}     | {:02X}     | {:02X}     | {:02X}", xor_reversed[0], xor_reversed[1], xor_reversed[2], xor_reversed[3]);
println!("Perm Rev    | {:02X}     | {:02X}     | {:02X}     | {:02X}", permuted_reversed[0], permuted_reversed[1], permuted_reversed[2], permuted_reversed[3]);
println!("Decrypted   | {:02X}     | {:02X}     | {:02X}     | {:02X}", decrypted[0], decrypted[1], decrypted[2], decrypted[3]);
<span class="boring">}</span></code></pre></pre>
<p>Why it works</p>
<ul>
<li>Substitution = confusion → Hide relationships between plaintext and ciphertext</li>
<li>Permutation = diffusion → Spread input influence across the block</li>
</ul>
<p>These are Shannon’s two pillars of secure ciphers.</p>
<blockquote>
<p>💡 Claude Shannon, widely considered the father of modern cryptography, introduced the concepts of confusion and diffusion in 1949 as the foundation of secure cipher design.</p>
</blockquote>
<blockquote>
<p><strong>🟢 Conclusion</strong><br />
Substitution-Permutation Networks provide a simple yet powerful structure for building symmetric ciphers. They deliver the critical properties of confusion and diffusion, as first formalized by Claude Shannon in his foundational work on cryptographic security.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
