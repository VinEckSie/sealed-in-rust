<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>2.1. Symmetric Ciphers ‚Äî XOR, AES, ChaCha20 - Sealed in Rust ‚Äî Domain-Driven Edition</title>


        <!-- Custom HTML head -->

        <meta name="description" content="The example book covers examples.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Sealed in Rust ‚Äî Domain-Driven Edition</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/mdBook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/mdBook/edit/master/guide/src/02-core-primitives/02-01-symmetric-ciphers.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="symmetric-ciphers-xor-aes-chacha20--beyond"><a class="header" href="#symmetric-ciphers-xor-aes-chacha20--beyond">Symmetric Ciphers: XOR, AES, ChaCha20 &amp; Beyond</a></h2>
<blockquote>
<p>üîê <strong>Used in:</strong> VPNs, TLS (post-handshake), disk encryption, messaging apps<br />
‚úÖ Still foundational in modern cryptography.</p>
</blockquote>
<h3 id="what-are-symmetric-ciphers"><a class="header" href="#what-are-symmetric-ciphers">What Are Symmetric Ciphers?</a></h3>
<p>Symmetric ciphers use the <strong>same key</strong> for both encryption and decryption. Unlike public-key cryptography, they don‚Äôt offer key exchange‚Äîbut they are <strong>much faster</strong>, making them ideal for bulk data encryption.</p>
<p>They are used everywhere: encrypted file systems, secure communications, and even inside protocols like TLS (after the handshake).</p>
<h3 id="xor-cipher--simplicity-that-teaches"><a class="header" href="#xor-cipher--simplicity-that-teaches">XOR Cipher ‚Äî Simplicity That Teaches</a></h3>
<blockquote>
<p>‚ö†Ô∏è Insecure. Demonstration-only (used in educational demos, malware obfuscation )</p>
</blockquote>
<p>Watch it on my <em>Fearless in Rust</em> channel: <a href="https://www.youtube.com/watch?v=wA-p_c19ZFw&amp;t=326s">XOR Cipher in Rust - Step by Step</a></p>
<!--
>‚ö†Ô∏è Annotate if a Rust crate exists + maturity level
-->
<p>We first explored XOR encryption in <a href="../01-foundations/01-04-first-code.html">Section 1.4: First Code ‚Äî A Naive XOR Encryptor</a>, where we built a full working example from scratch.</p>
<p>XOR is the simplest symmetric cipher: each byte of the message is XORed with a repeating key.
Reversibility is built-in ‚Äî XORing twice with the same key restores the original.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let message = b"Hi, Rust!";
    let key = b"key";

    let encrypted = xor_encrypt(message, key);
    let decrypted = xor_encrypt(&amp;encrypted, key);

    println!("Encrypted: {:x?}", encrypted);
    println!("Decrypted: {}", String::from_utf8_lossy(&amp;decrypted));
}

pub fn xor_encrypt(input: &amp;[u8], key: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    input
        .iter()
        .enumerate()
        .map(|(i, &amp;byte)| byte ^ key[i % key.len()])
        .collect()
}</code></pre></pre>
<blockquote>
<p><strong>üü¢ Conclusion</strong>
XOR encryption is reversible and stateless, which makes it simple and fast. But it lacks confusion and diffusion, so patterns in the input remain visible ‚Äî offering no real resistance to cryptanalysis.</p>
</blockquote>
<h3 id="feistel-networks--foundation-of-classic-block-ciphers"><a class="header" href="#feistel-networks--foundation-of-classic-block-ciphers">Feistel Networks ‚Äî Foundation of Classic Block Ciphers</a></h3>
<blockquote>
<p>‚ö†Ô∏è Cryptographically obsolete, but conceptually important (used in DES<sup class="footnote-reference" id="fr-DES-1"><a href="#footnote-DES">1</a></sup>, 3DES<sup class="footnote-reference" id="fr-3DES-1"><a href="#footnote-3DES">2</a></sup>)</p>
</blockquote>
<!--
> ‚ö†Ô∏èÔ∏è Annotate if a Rust crate exists + maturity level
-->
<p>Feistel networks are a clever way to build reversible encryption using any basic function‚Äîeven if that function itself can‚Äôt be reversed. That‚Äôs the key idea.</p>
<p>Each round applies a transformation to the data. Multiple rounds are chained to strengthen security.</p>
<p>Each round does the following:</p>
<ol>
<li>Takes two halves: Left (L) and Right (R)</li>
<li>Computes a function f(R, key)</li>
<li>Updates the pair as:</li>
</ol>
<pre><code class="language-vbnet">L‚ÇÇ = R‚ÇÅ
R‚ÇÇ = L‚ÇÅ ‚äï f(R‚ÇÅ, key)
</code></pre>
<p>To encrypt, let‚Äôs see it in Rust:</p>
<pre><pre class="playground"><code class="language-rust">fn feistel_round(l: u8, r: u8, k: u8) -&gt; (u8, u8) {
    let f = r ^ k;
    (r, l ^ f)
}

fn main() {
    let left1: u8 = 0b1010_1010;  // 170
    let right1: u8 = 0b0101_0101; // 85
    let key: u8 = 0b1111_0000;   // 240

    let (left2, right2) = feistel_round(left1, right1, key);
    println!("Encrypted: ({}, {})", left2, right2);
}</code></pre></pre>
<p>Decryption reuses the same function f, simply reversing the round transformation:</p>
<pre><pre class="playground"><code class="language-rust">fn feistel_round(l1: u8, r1: u8, k: u8) -&gt; (u8, u8) {
    let f = r1 ^ k;
    (r1, l1 ^ f)
}

fn feistel_decrypt(l2: u8, r2: u8, k: u8) -&gt; (u8, u8) {
    let f = l2 ^ k;
    let l1 = r2 ^ f;
    (l1, l2)
}

fn main() {
    let left1: u8 = 0b1010_1010;  // 170
    let right1: u8 = 0b0101_0101; // 85
    let key: u8 = 0b1111_0000;   // 240

    let (left2, right2) = feistel_round(left1, right1, key);
    println!("Encrypted: ({}, {})", left2, right2);

    let (left_orig, right_orig) = feistel_decrypt(left2, right2, key);
    println!("Decrypted: ({}, {})", left_orig, right_orig);
}</code></pre></pre>
<br>
Because encryption produces :
<pre><code class="language-pgsql">Encrypted ‚Üí (R, L ‚äï f(R, k))
</code></pre>
<p>Let‚Äôs define:</p>
<ul>
<li>L‚ÇÅ and R‚ÇÅ = original input</li>
<li>L‚ÇÇ = R‚ÇÅ and R‚ÇÇ = L‚ÇÅ ‚äï f(R‚ÇÅ, k)</li>
</ul>
<p>We receive (L‚ÇÇ, R‚ÇÇ) and want to recover (L‚ÇÅ, R‚ÇÅ):</p>
<ol>
<li>
<p>From encryption, we know L‚ÇÇ = R‚ÇÅ</p>
<ul>
<li>So: R‚ÇÅ = L‚ÇÇ</li>
</ul>
</li>
<li>
<p>And: R‚ÇÇ = L‚ÇÅ ‚äï f(R‚ÇÅ, k)</p>
<ul>
<li>Replace R‚ÇÅ with L‚ÇÇ</li>
<li>R‚ÇÇ = L‚ÇÅ ‚äï f(L‚ÇÇ, k)</li>
</ul>
</li>
<li>
<p>Rearranging to get L‚ÇÅ:</p>
<ul>
<li>L‚ÇÅ = R‚ÇÇ ‚äï f(L‚ÇÇ, k)</li>
</ul>
</li>
</ol>
<br>
So, decryption is
<pre><code class="language-pgsql">L‚ÇÅ = R‚ÇÇ ‚äï f(L‚ÇÇ, k)
R‚ÇÅ = L‚ÇÇ
</code></pre>
<blockquote>
<p><strong>üü¢ Conclusion</strong><br />
Reversibility comes from XOR being reversible and swapping the halves.
Feistel networks let you build reversible encryption even with non-invertible functions.
This idea shaped DES and similar ciphers.</p>
<p>Not used today due to known vulnerabilities, but conceptually essential.</p>
</blockquote>
<h3 id="substitutionpermutation-networks-spn"><a class="header" href="#substitutionpermutation-networks-spn">Substitution‚ÄìPermutation Networks (SPN)</a></h3>
<blockquote>
<p>‚ö†Ô∏è Software-only S-box implementations can leak secrets through cache timing. Modern AES implementations use hardware instructions (AES-NI) or constant-time software libraries.</p>
</blockquote>
<blockquote>
<p>‚ö†Ô∏è Used in AES<sup class="footnote-reference" id="fr-AES-1"><a href="#footnote-AES">3</a></sup>, Camellia<sup class="footnote-reference" id="fr-Camellia-1"><a href="#footnote-Camellia">4</a></sup>, and modern block ciphers.
Still dominant in current cipher architectures</p>
</blockquote>
<!--
> ‚ö†Ô∏è Annotate if a Rust crate exists + maturity level
-->
<p>Substitution-Permutation Networks (SPNs) are a powerful way to build secure block ciphers by layering simple operations repeated across multiple rounds to build a secure cipher.</p>
<p>Each round does the following:</p>
<ol>
<li>Substitution ‚Äì replace each byte using an S-box (non-linear mapping)</li>
<li>Permutation ‚Äì reorder bits or bytes to spread influence</li>
<li>Key mixing ‚Äì XOR the block with a round key</li>
</ol>
<p>Decryption reverses these steps in reverse order.</p>
<blockquote>
<p>üí° An S-box (substitution box) is a predefined table that maps each input byte to a new output byte.
Its goal is to introduce non-linearity ‚Äî meaning the output doesn‚Äôt follow any simple, predictable rule based on the input.
<br><br>
This non-linear mapping ensures that small changes in the input produce unpredictable changes in the output, making it impossible to reverse or model with linear equations ‚Äî a key requirement for secure encryption.</p>
</blockquote>
<br>
Let‚Äôs walk through a simple encryption of a 4-byte block.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::TryInto;

// Manually defined "shuffled" S-box (shortened for demo)
let s_box: [u8; 16] = [
   0x63, 0x7C, 0x77, 0x7B,
   0xF2, 0x6B, 0x6F, 0xC5,
   0x30, 0x01, 0x67, 0x2B,
   0xFE, 0xD7, 0xAB, 0x76,
];

// Step 1: Substitution with S-box
// ‚ö†Ô∏è input and output (substituted) must have the same size
// Otherwise, map() or indexing will panic at runtime
let input: [u8; 4] = [0x00, 0x03, 0x07, 0x0F];
let substituted: [u8; 4] = input.map(|b| s_box[b as usize]);

// Step 2: Permutation (custom byte reordering)
let permuted: [u8; 4] = [
   substituted[2], // byte 2 moves to pos 0
   substituted[0], // byte 0 ‚Üí pos 1
   substituted[3], // byte 3 ‚Üí pos 2
   substituted[1], // byte 1 ‚Üí pos 3
];

// Step 3: XOR with round key
let round_key: [u8; 4] = [0xF0, 0x0F, 0xAA, 0x55];
let encrypted: [u8; 4] = permuted
   .iter()
   .zip(round_key.iter())
   .map(|(a, b)| a ^ b)
   .collect::&lt;Vec&lt;u8&gt;&gt;()
   .try_into()
   .unwrap();


println!("Step        | Byte 0 | Byte 1 | Byte 2 | Byte 3");
println!("------------|--------|--------|--------|--------");
println!("Input       | {:02X}     | {:02X}     | {:02X}     | {:02X}", input[0], input[1], input[2], input[3]);
println!("Substituted | {:02X}     | {:02X}     | {:02X}     | {:02X}", substituted[0], substituted[1], substituted[2], substituted[3]);
println!("Permuted    | {:02X}     | {:02X}     | {:02X}     | {:02X}", permuted[0], permuted[1], permuted[2], permuted[3]);
println!("Encrypted   | {:02X}     | {:02X}     | {:02X}     | {:02X}", encrypted[0], encrypted[1], encrypted[2], encrypted[3]);
<span class="boring">}</span></code></pre></pre>
<br>
To decrypt, reverse the steps in reverse order:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::TryInto;

// Same S-box used for encryption
let s_box: [u8; 16] = [
   0x63, 0x7C, 0x77, 0x7B,
   0xF2, 0x6B, 0x6F, 0xC5,
   0x30, 0x01, 0x67, 0x2B,
   0xFE, 0xD7, 0xAB, 0x76,
];

// Generate inverse S-box
let mut inverse_s_box = [0u8; 256];
for (i, &amp;val) in s_box.iter().enumerate() {
   inverse_s_box[val as usize] = i as u8;
}

// Encrypted block from the previous encryption output
let encrypted: [u8; 4] = [0x35, 0x6C, 0xDC, 0x2E];
let round_key: [u8; 4] = [0xF0, 0x0F, 0xAA, 0x55];

// Step 1: Undo XOR with round key
let xor_reversed: [u8; 4] = encrypted
        .iter()
        .zip(round_key.iter())
        .map(|(a, b)| a ^ b)
        .collect::&lt;Vec&lt;u8&gt;&gt;()
        .try_into()
        .unwrap();

// Step 2:  Reverse permutation
// Remember: original permutation was [2, 0, 3, 1]
// So now we must do: [1, 3, 0, 2]
let permuted_reversed: [u8; 4] = [
   xor_reversed[1], // was originally at index 0
   xor_reversed[3], // was at index 1
   xor_reversed[0], // was at index 2
   xor_reversed[2], // was at index 3
];

// Step 3: Inverse substitution using inverse_s_box
let decrypted: [u8; 4] = permuted_reversed.map(|b| inverse_s_box[b as usize]);


println!("Step        | Byte 0 | Byte 1 | Byte 2 | Byte 3");
println!("------------|--------|--------|--------|--------");
println!("Encrypted   | {:02X}     | {:02X}     | {:02X}     | {:02X}", encrypted[0], encrypted[1], encrypted[2], encrypted[3]);
println!("XOR Rev     | {:02X}     | {:02X}     | {:02X}     | {:02X}", xor_reversed[0], xor_reversed[1], xor_reversed[2], xor_reversed[3]);
println!("Perm Rev    | {:02X}     | {:02X}     | {:02X}     | {:02X}", permuted_reversed[0], permuted_reversed[1], permuted_reversed[2], permuted_reversed[3]);
println!("Decrypted   | {:02X}     | {:02X}     | {:02X}     | {:02X}", decrypted[0], decrypted[1], decrypted[2], decrypted[3]);
<span class="boring">}</span></code></pre></pre>
<p>Why it works</p>
<ul>
<li>Substitution = confusion ‚Üí Hide relationships between plaintext and ciphertext</li>
<li>Permutation = diffusion ‚Üí Spread input influence across the block</li>
</ul>
<p>These are Shannon‚Äôs two pillars of secure ciphers.</p>
<blockquote>
<p>üí° Claude Shannon, widely considered the father of modern cryptography, introduced the concepts of confusion and diffusion in 1949 as the foundation of secure cipher design.</p>
</blockquote>
<blockquote>
<p><strong>üü¢ Conclusion</strong><br />
Substitution-Permutation Networks provide a simple yet powerful structure for building symmetric ciphers. They deliver the critical properties of confusion and diffusion, as first formalized by Claude Shannon in his foundational work on cryptographic security.</p>
</blockquote>
<h3 id="aes-advanced-encryption-standard---the-global-symmetric-standard"><a class="header" href="#aes-advanced-encryption-standard---the-global-symmetric-standard">AES (Advanced Encryption Standard)  ‚Äî The Global Symmetric Standard</a></h3>
<blockquote>
<p>üí° Used in TLS<sup class="footnote-reference" id="fr-TLS-1"><a href="#footnote-TLS">5</a></sup>, LUKS<sup class="footnote-reference" id="fr-LUKS-1"><a href="#footnote-LUKS">6</a></sup>, SSH<sup class="footnote-reference" id="fr-SSH-1"><a href="#footnote-SSH">7</a></sup>, mobile apps, and FIPS-certified systems<sup class="footnote-reference" id="fr-FIPS-1"><a href="#footnote-FIPS">8</a></sup>.<br />
Secure, fast, and hardware-accelerated</p>
</blockquote>
<blockquote>
<p><img src="../images/cargo.png" alt="My Crate Logo" width="22" style="vertical-align: middle; margin-right: 6px;"> Crates used: <a href="https://crates.io/crates/aes">aes</a>, <a href="https://github.com/RustCrypto/block-modes">block_modes</a></p>
</blockquote>
<p>AES is a symmetric-key block cipher developed by Belgian cryptographers Vincent Rijmen and Joan Daemen. It was selected by NIST in 2001 as the successor to DES and 3DES.</p>
<p>AES operates on 128-bit blocks and supports key sizes of 128, 192, or 256 bits. It is based on a Substitution‚ÄìPermutation Network (SPN) and runs 10, 12, or 14 rounds depending on the key length.</p>
<p>It is standardized by FIPS-197, ISO/IEC<sup class="footnote-reference" id="fr-ISOIEC-1"><a href="#footnote-ISOIEC">9</a></sup>, and widely adopted in security protocols such as TLS, SSH, and IPsec<sup class="footnote-reference" id="fr-IPSec-1"><a href="#footnote-IPSec">10</a></sup>. AES is available in hardware on most modern CPUs, making it both fast and energy-efficient.</p>
<br>
<p>üß™ <strong>Code Example: AES-128-CBC Encryption &amp; Decryption in Rust</strong>  (<a href="https://github.com/VinEckSie/sealed-in-rust/blob/main/rust_crypto_book_code/src/lib.rs">source code</a>)<br />
We‚Äôll use the aes and block-modes crates to encrypt and decrypt a message using AES-128 in CBC mode<sup class="footnote-reference" id="fr-CBC-1"><a href="#footnote-CBC">11</a></sup> with PKCS7<sup class="footnote-reference" id="fr-PKCS7-1"><a href="#footnote-PKCS7">12</a></sup> padding.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use aes::Aes128;
use block_padding::Pkcs7;
use cbc::{Encryptor, Decryptor};
use cipher::{BlockEncryptMut, BlockDecryptMut, KeyIvInit};


pub fn run_aes_example() {

    let key = b"verysecretkey123";
    let iv = b"uniqueinitvector";
    let plaintext = b"Attack at dawn!";

    let mut buffer = plaintext.to_vec();
    let pos = buffer.len();
    buffer.resize(pos + 16, 0u8);

    let mut encryptor = Encryptor::&lt;Aes128&gt;::new(key.into(), iv.into());
    let ciphertext = encryptor
        .encrypt_padded_mut::&lt;Pkcs7&gt;(&amp;mut buffer, pos)
        .expect("encryption failure");

    println!("Ciphertext (hex): {}", hex::encode(ciphertext));

    let mut decryptor = Decryptor::&lt;Aes128&gt;::new(key.into(), iv.into());

    let mut ciphertext_buffer = ciphertext.to_vec(); // make it mutable
    let decrypted = decryptor
        .decrypt_padded_mut::&lt;Pkcs7&gt;(&amp;mut ciphertext_buffer)
        .expect("decryption failure");


    println!("Decrypted text: {}", String::from_utf8_lossy(decrypted));
    assert_eq!(plaintext.to_vec(), decrypted);
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Ciphertext (hex): 61b05644915a98fbd515e31b3a4e6d88
Decrypted text: Attack at dawn!
<span class="boring">}</span></code></pre></pre>
<p>‚úÖ Use a unique IV (Initialization Vector) for every encryption, and never reuse a key/IV pair. Avoid ECB mode entirely, and prefer AEAD modes (e.g., AES-GCM) when available.</p>
<blockquote>
<p><strong>üü¢ Conclusion</strong>
AES is the modern standard for symmetric encryption. It is fast, secure, and hardware-accelerated ‚Äî making it ideal for both embedded systems and high-throughput servers. When used correctly with a secure mode like CBC or GCM and proper key/IV management, AES provides strong resistance against all known practical attacks.</p>
</blockquote>
<hr>
<ol class="footnote-definition"><li id="footnote-DES">
<p>DES ‚Äî early symmetric cipher (56-bit), now insecure. <a href="../99-appendices/99-01-glossary.html#des-data-encryption-standard">More</a> <a href="#fr-DES-1">‚Ü©</a></p>
</li>
<li id="footnote-3DES">
<p>3DES ‚Äî DES applied three times, better than DES but now deprecated. <a href="../99-appendices/99-01-glossary.html#3des-triple-des">More</a> <a href="#fr-3DES-1">‚Ü©</a></p>
</li>
<li id="footnote-AES">
<p>AES ‚Äî The modern global standard, fast, secure, and hardware-accelerated. <a href="../99-appendices/99-01-glossary.html#aes-advanced-encryption-standard">More</a> <a href="#fr-AES-1">‚Ü©</a></p>
</li>
<li id="footnote-Camellia">
<p>Camellia ‚Äî Japanese block cipher, secure &amp; AES-comparable. <a href="../99-appendices/99-01-glossary.html#camellia">More</a> <a href="#fr-Camellia-1">‚Ü©</a></p>
</li>
<li id="footnote-TLS">
<p>TLS ‚Äî protocol securing data in transit (HTTPS, etc.). <a href="../99-appendices/99-01-glossary.html#tls-transport-layer-security">More</a> <a href="#fr-TLS-1">‚Ü©</a></p>
</li>
<li id="footnote-LUKS">
<p>LUKS ‚Äî Linux standard for full disk encryption. <a href="../99-appendices/99-01-glossary.html#luks-linux-unified-key-setup">More</a> <a href="#fr-LUKS-1">‚Ü©</a></p>
</li>
<li id="footnote-SSH">
<p>SSH ‚Äî secure remote access protocol. <a href="../99-appendices/99-01-glossary.html#ssh-secure-shell">More</a> <a href="#fr-SSH-1">‚Ü©</a></p>
</li>
<li id="footnote-FIPS">
<p>FIPS ‚Äî U.S. cryptographic standards for government/finance. <a href="../99-appendices/99-01-glossary.html#fips-federal-information-processing-standards">More</a> <a href="#fr-FIPS-1">‚Ü©</a></p>
</li>
<li id="footnote-ISOIEC">
<p>ISO/IEC ‚Äî international standards for IT/crypto. <a href="../99-appendices/99-01-glossary.html#isoiec">More</a> <a href="#fr-ISOIEC-1">‚Ü©</a></p>
</li>
<li id="footnote-IPSec">
<p>IPSec ‚Äî protocol suite for securing IP communications. <a href="../99-appendices/99-01-glossary.html#ipsec">More</a> <a href="#fr-IPSec-1">‚Ü©</a></p>
</li>
<li id="footnote-CBC">
<p>CBC ‚Äî block cipher mode, chains blocks for security. <a href="../99-appendices/99-01-glossary.html#cbc-cipher-block-chaining">More</a> <a href="#fr-CBC-1">‚Ü©</a></p>
</li>
<li id="footnote-PKCS7">
<p>PKCS7 ‚Äî padding scheme for block ciphers. <a href="../99-appendices/99-01-glossary.html#pkcs7">More</a> <a href="#fr-PKCS7-1">‚Ü©</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../01-foundations/01-05-tooling-up.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../99-appendices/99-01-glossary.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../01-foundations/01-05-tooling-up.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../99-appendices/99-01-glossary.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
