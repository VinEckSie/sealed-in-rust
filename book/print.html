<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sealed in Rust — Domain-Driven Edition</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="The example book covers examples.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Sealed in Rust — Domain-Driven Edition</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/mdBook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>Cryptography is everywhere — and yet most of us treat it like magic.</strong></p>
<p>From encrypted chats and online banking to firmware updates on satellites, the systems we rely on daily are secured (or compromised) by cryptography. And too often, it fails — not because the math was wrong, but because the implementation was.</p>
<p><strong>This book exists to change that.</strong></p>
<p>You’re not here to memorize equations. You’re here to understand, implement, and apply cryptographic primitives to real-world systems using a language designed to prevent mistakes before they happen: <strong>Rust</strong>.</p>
<p>Whether you’re building infrastructure, smart contracts, embedded firmware, or secure APIs, this book gives you the tools to use cryptography safely, idiomatically, and fearlessly — one primitive, one project, one domain at a time.</p>
<h2 id="who-this-book-is-for"><a class="header" href="#who-this-book-is-for">Who This Book Is For</a></h2>
<ul>
<li>Rust developers who want to understand and apply cryptography</li>
<li>Security engineers transitioning to Rust</li>
<li>Curious hackers tired of black-box crypto</li>
<li>Systems developers who care about safety, correctness, and resilience</li>
</ul>
<h2 id="what-youll-learn"><a class="header" href="#what-youll-learn">What You’ll Learn</a></h2>
<ul>
<li>The foundations and mental models behind symmetric and asymmetric cryptography</li>
<li>How to use modern cryptographic crates in Rust safely and idiomatically</li>
<li>Where cryptographic primitives show up in real-world domains (blockchain, embedded, medical, etc.)</li>
<li>How to design, test, and publish your own secure Rust crypto crate</li>
</ul>
<h2 id="what-this-book-is-not"><a class="header" href="#what-this-book-is-not">What This Book Is Not</a></h2>
<ul>
<li>❌ A math-heavy cryptography textbook</li>
<li>❌ A copy-paste cookbook</li>
<li>❌ A blockchain hype manual</li>
</ul>
<p>We won’t drown you in proofs, but we’ll explain just enough math to build intuition. We’ll write real code — not just use libraries. And we’ll focus on systems-level crypto, not speculative tokens.</p>
<h2 id="what-youll-need"><a class="header" href="#what-youll-need">What You’ll Need</a></h2>
<ul>
<li>✅ Basic experience with Rust (enough to build a CLI or follow <code>cargo run</code>)</li>
<li>✅ Comfort with reading code, refactoring, and using crates</li>
<li>✅ Curiosity, and a bias toward safe, practical, applied learning</li>
</ul>
<h2 id="lets-begin"><a class="header" href="#lets-begin">Let’s begin</a></h2>
<p>This book won’t make you a cryptographer in the academic sense — but it will make you something just as rare and valuable:
A Rust engineer who understands, wields, and applies cryptography with precision, context, and confidence.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to Use This Book</a></h1>
<p>This book is designed to be practical, modular, and domain-focused.<br />
You can read it front to back, or jump directly to the domains and primitives most relevant to your work.</p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>The book is organized into four major parts:</p>
<p><strong>Foundations</strong> — Why Rust is uniquely suited for secure cryptographic engineering<br />
<strong>Primitives</strong> — The core building blocks of cryptography, with Rust-focused usage and implementation<br />
<strong>Applied Domains</strong> — Real-world systems and how they use cryptography in practice (blockchain, defense, aerospace, medical, infrastructure, etc.)<br />
<strong>Crate Building</strong> — How to architect, test, audit, and publish your own cryptographic crate in Rust</p>
<h3 id=""><a class="header" href="#"></a></h3>
<p>Each chapter includes:</p>
<ul>
<li>Plain-language explanations</li>
<li>Rust code examples using community crates</li>
<li>Security insights and common pitfalls</li>
<li>Domain-specific applications</li>
</ul>
<h2 id="code-and-examples"><a class="header" href="#code-and-examples">Code and Examples</a></h2>
<p>Most chapters include runnable Rust code to illustrate key concepts.</p>
<ul>
<li>You’ll need a working Rust toolchain (<code>rustup</code>, <code>cargo</code>)</li>
<li>Code examples are written for Rust 2021 edition</li>
</ul>
<!--- All examples are hosted in [a separate repository](https://github.com/VinEckSie/sealed-in-rust-examples)-->
<p>Each folder in that repo corresponds to a chapter or concept from the book.<br />
You can clone it, run the examples, and experiment freely without touching production code or complex crates.</p>
<blockquote>
<p><strong>Note:</strong> These examples are minimal and didactic. They are not full cryptographic libraries.</p>
</blockquote>
<!--If you're looking for a complete, idiomatic crypto crate, see my separate library: [Cryon](https://github.com/VinEckSie/cryon)-->
<h2 id="non-linear-reading"><a class="header" href="#non-linear-reading">Non-linear Reading</a></h2>
<p>This book doesn’t assume linear progress.</p>
<ul>
<li>Want to build a secure file encryption tool? <strong>Symmetric Ciphers</strong> + <strong>Secure Infrastructure</strong></li>
<li>Curious about smart contracts? Go directly to <strong>ECC</strong> and <strong>Blockchain &amp; Web3</strong></li>
<li>Working on embedded firmware? Check out <strong>Ascon</strong>, <strong>PRESENT</strong>, and <strong>Defense &amp; Aerospace</strong></li>
</ul>
<p>Each domain chapter reminds you of the necessary primitives — like a map, not a locked path.</p>
<h2 id="contributing-feedback--issues"><a class="header" href="#contributing-feedback--issues">Contributing, Feedback, &amp; Issues</a></h2>
<p>This book is a living project.</p>
<ul>
<li>Errors? Open an issue or PR on the <a href="https://github.com/VinEckSie/sealed-in-rust">GitHub repo</a></li>
<li>Suggestions? You’re welcome to share ideas for domains, examples, or improvements</li>
<li>Contributions to the examples repo are also welcome</li>
</ul>
<h2 id="final-note"><a class="header" href="#final-note">Final Note</a></h2>
<p>This is not a cryptography textbook — it’s a cryptographic engineering manual.<br />
By the end, you’ll not only understand the primitives, you’ll know how to use them to secure real systems — in Rust, by design, not by accident.</p>
<p>Let’s begin.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cryptography-is-a-systems-problem"><a class="header" href="#cryptography-is-a-systems-problem">Cryptography is a Systems Problem</a></h2>
<p>Cryptography isn’t just about math.</p>
<p>Yes, it starts with elegant algebra and deep number theory — but where it breaks is almost always <em>in the system</em>. Real-world failures come from poor implementations, leaky abstractions, memory bugs, side channels, or simply misunderstanding what problem crypto is supposed to solve.</p>
<p>It’s easy to misuse even “secure” primitives. AES<sup class="footnote-reference" id="fr-aes-1"><a href="#footnote-aes">1</a></sup> in ECB mode<sup class="footnote-reference" id="fr-ecb-1"><a href="#footnote-ecb">2</a></sup> is fast — and useless. RSA<sup class="footnote-reference" id="fr-rsa-1"><a href="#footnote-rsa">3</a></sup> without padding<sup class="footnote-reference" id="fr-padding-1"><a href="#footnote-padding">4</a></sup> is a gift to attackers. And a perfectly strong key means nothing if it’s printed to your logs.</p>
<p>This is why cryptography is a <strong>systems engineering problem</strong> first.</p>
<p>And it’s why Rust matters.</p>
<p>Rust doesn’t make crypto correct by default — nothing does — but it gives you tools to <strong>avoid entire classes of catastrophic bugs</strong>.</p>
<p>Memory safety, explicit ownership, fearless concurrency, and tight control over the machine — these aren’t “nice to have.” They’re security features.</p>
<h3 id="-1"><a class="header" href="#-1"></a></h3>
<p>In this book, we’ll treat crypto not as a black box, but as a series of concrete systems problems — and show how Rust lets us solve them with clarity and precision.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-aes">
<p>AES (Advanced Encryption Standard) is a widely used symmetric cipher known for its performance and strong security — when used correctly. <a href="#fr-aes-1">↩</a></p>
</li>
<li id="footnote-ecb">
<p>ECB (Electronic Code Book) mode encrypts each block independently, revealing patterns in the plaintext and making it insecure for most purposes. <a href="#fr-ecb-1">↩</a></p>
</li>
<li id="footnote-rsa">
<p>RSA (Rivest–Shamir–Adleman) is a public-key cryptosystem used for encryption and digital signatures. It relies on the difficulty of factoring large integers. <a href="#fr-rsa-1">↩</a></p>
</li>
<li id="footnote-padding">
<p>Padding in RSA adds randomness or structure to the plaintext before encryption, preventing deterministic outputs. Without it, attackers can guess messages, detect patterns, or exploit mathematical properties to break the cipher. <a href="#fr-padding-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h2 id="safety-performance-predictability"><a class="header" href="#safety-performance-predictability">Safety, Performance, Predictability</a></h2>
<p>Rust is often praised for its speed and memory safety, but in the world of cryptographic engineering, these traits aren’t just nice-to-haves — they’re critical.</p>
<h3 id="safety"><a class="header" href="#safety">Safety</a></h3>
<p>Bugs in cryptographic code can be catastrophic. Memory corruption, undefined behavior, or uninitialized values can leak secrets or open attack vectors. Rust eliminates entire classes of these bugs at compile time:</p>
<ul>
<li>No nulls</li>
<li>No uninitialized memory</li>
<li>No data races</li>
<li>No buffer overflows</li>
</ul>
<p>This safety isn’t enforced by a runtime, but by the <strong>borrow checker</strong> at compile time. That makes Rust extremely attractive for writing low-level cryptographic code <strong>without sacrificing control</strong>.</p>
<h3 id="performance"><a class="header" href="#performance">️Performance</a></h3>
<p>Rust compiles to fast native code, comparable to C and C++. There’s no garbage collector, and you pay only for what you use. This matters because cryptography is often used in:</p>
<ul>
<li>Performance-critical code paths (e.g. TLS handshakes, file encryption)</li>
<li>Embedded systems where CPU cycles and memory are limited</li>
</ul>
<p>Rust lets you stay close to the metal while writing high-level abstractions — it’s a rare balance.</p>
<h3 id="predictability"><a class="header" href="#predictability">Predictability</a></h3>
<p>In cryptography, <strong>predictable behavior</strong> is essential. You need fine-grained control over:</p>
<ul>
<li><strong>Timing</strong> — Avoid accidental leaks via early-exit comparisons or branching on secrets</li>
<li><strong>Memory</strong> — Prevent unexpected reallocations or optimization side effects</li>
<li><strong>Execution</strong> — Ensure constant-time logic without interference from JITs or hidden runtime behavior</li>
</ul>
<p>Rust gives you this control by default, making it a strong ally in defending against side-channel attacks.</p>
<blockquote>
<p>In short: Rust brings the low-level control of C, the safety of functional languages, and the clarity of modern syntax — all in a single toolchain. That’s why cryptographers and security engineers are increasingly turning to it.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-cost-of-unsafety-in-crypto-famous-failures"><a class="header" href="#the-cost-of-unsafety-in-crypto-famous-failures">The Cost of Unsafety in Crypto: Famous Failures</a></h2>
<p>Cryptography doesn’t fail because math is broken — it fails because <strong>systems leak</strong>, <strong>code panics</strong>, or <strong>side-channels whisper secrets</strong>.<br><br>
And most of these failures? They stem from unsafety.
<br><br><br>
Here are just a few real-world examples of cryptographic disasters caused by unsafe programming, undefined behavior, or lack of control:</p>
<h4 id="heartbleed-2014"><a class="header" href="#heartbleed-2014">Heartbleed (2014)</a></h4>
<ul>
<li><strong>Cause:</strong> Buffer over-read in OpenSSL (written in C)</li>
<li><strong>Impact:</strong> Leaked private keys, passwords, and session data from millions of servers</li>
<li><strong>Lesson:</strong> Unsafe memory access can silently expose secrets</li>
</ul>
<h4 id="debian-rng-bug-20062008"><a class="header" href="#debian-rng-bug-20062008">Debian RNG Bug (2006–2008)</a></h4>
<ul>
<li><strong>Cause:</strong> A developer commented out entropy-gathering code in OpenSSL</li>
<li><strong>Impact:</strong> Generated only 32,768 possible SSH keys across all Debian systems</li>
<li><strong>Lesson:</strong> Cryptographic quality often hinges on <strong>deterministic, auditable behavior</strong></li>
</ul>
<h4 id="lucky13-attack-2013"><a class="header" href="#lucky13-attack-2013">Lucky13 Attack (2013)</a></h4>
<ul>
<li><strong>Cause:</strong> Tiny timing differences in CBC mode padding checks (TLS)</li>
<li><strong>Impact:</strong> Allowed attackers to decrypt data by measuring how long responses took</li>
<li><strong>Lesson:</strong> Timing leaks can <strong>invalidate encryption</strong>, even with perfect math</li>
</ul>
<h4 id="javascript-crypto-fails"><a class="header" href="#javascript-crypto-fails">JavaScript Crypto Fails</a></h4>
<ul>
<li><strong>Cause:</strong> Misuse of <code>Math.random()</code> or insecure key handling in frontend apps</li>
<li><strong>Impact:</strong> Predictable keys, insecure password storage, and non-constant-time comparisons</li>
<li><strong>Lesson:</strong> Languages with hidden optimizations make <strong>constant-time logic fragile</strong></li>
</ul>
<h3 id="why-rust-helps"><a class="header" href="#why-rust-helps">Why Rust Helps</a></h3>
<p>Rust’s safety model eliminates whole classes of vulnerabilities:</p>
<ul>
<li>No null/dangling pointers</li>
<li>No uninitialized memory</li>
<li>Memory-safe concurrency</li>
<li>Deterministic behavior at runtime (no GC pauses, no JIT surprise)</li>
</ul>
<p>You still have to <strong>design crypto carefully</strong>, but with Rust, you’re not building it on quicksand.</p>
<blockquote>
<p>Writing secure cryptography in unsafe languages is like writing legal contracts with disappearing ink.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="first-code-a-naive-xor-encryptor"><a class="header" href="#first-code-a-naive-xor-encryptor">First Code: A Naive XOR Encryptor</a></h2>
<p>Let’s write our first cryptographic algorithm — or at least something that <em>looks</em> like one.</p>
<p>We’ll implement a simple <strong>XOR cipher</strong>. This method is <em>insecure</em> and should never be used in real applications — but it’s the perfect teaching tool.</p>
<h3 id="whats-a-cipher"><a class="header" href="#whats-a-cipher">What’s a Cipher?</a></h3>
<p>A <strong>cipher</strong> is just a method to <strong>transform readable data (plaintext)</strong> into <strong>unreadable data (ciphertext)</strong> using a <strong>key</strong> — and vice versa.</p>
<blockquote>
<p>🧭 Word Origin — “Cipher”
The word comes from the Arabic “ṣifr” (صفر), meaning “zero” or “empty”. It passed through Latin (cifra), then into French and English as cipher.<br><br>
What started as a symbol for “nothing” evolved into a word for secret writing — and eventually, encryption algorithms.</p>
</blockquote>
<h3 id="what-is-xor"><a class="header" href="#what-is-xor">What is XOR?</a></h3>
<p>XOR stands for <strong>“exclusive or”</strong>, a bitwise operation:</p>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>B</th><th>A XOR B</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>0</td></tr>
</tbody></table>
</div>
<p>In short: XOR returns 1 if the bits differ, 0 if they’re the same.</p>
<p>The XOR operation flips bits when they differ:</p>
<pre><code class="language-text">1 ^ 0 = 1
1 ^ 1 = 0
0 ^ 0 = 0
</code></pre>
<p>When used for encryption:</p>
<pre><code class="language-text">cipher = plaintext ^ key
plaintext = cipher ^ key
</code></pre>
<p>That’s why XOR can be used to encrypt and decrypt data — if you XOR something twice with the same key, you get the original back.</p>
<blockquote>
<p>✅ Simple, reversible, fast — but also dangerously weak when misused.</p>
</blockquote>
<h3 id="xor-bit-by-bit"><a class="header" href="#xor-bit-by-bit">XOR, Bit by Bit</a></h3>
<p>To truly understand XOR in cryptography, it helps to look at bit-level behavior.</p>
<p>Let’s say you compute:</p>
<pre><code class="language-rust noplayground">100 ^ 1</code></pre>
<p>This doesn’t mean 100 to the power of 1. In Rust, ^ is the bitwise XOR operator.</p>
<p>Step-by-step:</p>
<pre><code class="language-yaml">100 = 0110 0100
1   = 0000 0001
---------------
XOR = 0110 0101 = 101
</code></pre>
<p>✅ Each bit is compared:
If they’re different → 1
If they’re the same → 0</p>
<pre><code class="language-rust noplayground">100 ^ 1 = 101</code></pre>
<p>This is what makes XOR useful: you can toggle bits with a key, and reverse it by applying the same key again.</p>
<h3 id="why-this"><a class="header" href="#why-this">Why This?</a></h3>
<p>This example teaches you:</p>
<ul>
<li>The reversible nature of XOR (<code>a ^ b ^ b == a</code>)</li>
<li>Handling bytes and slices in Rust</li>
<li>Thinking about encryption as a transformation</li>
<li>Why key reuse and simplicity are dangerous</li>
</ul>
<h3 id="naive-xor-in-rust"><a class="header" href="#naive-xor-in-rust">Naive XOR in Rust</a></h3>
<p>Here’s how to implement a basic XOR encryptor in Rust: <br></p>
<p>Filename: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let message = b"hello world";
    let key = b"key";

    let encrypted = xor_encrypt(message, key);
    let decrypted = xor_encrypt(&amp;encrypted, key);

    println!("Encrypted: {:x?}", encrypted);
    println!("Decrypted: {}", String::from_utf8_lossy(&amp;decrypted));
}

pub fn xor_encrypt(input: &amp;[u8], key: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    input
        .iter()
        .enumerate()
        .map(|(i, &amp;byte)| byte ^ key[i % key.len()])
        .collect()
}</code></pre></pre>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<p>The output will show the encrypted bytes (in hex) and the original decrypted message.</p>
<h3 id="whats-wrong-with-this-cipher"><a class="header" href="#whats-wrong-with-this-cipher">What’s Wrong With This Cipher?</a></h3>
<ul>
<li>Key reuse makes patterns obvious</li>
<li>No randomness or initialization vector (IV)</li>
<li>Susceptible to frequency analysis attacks</li>
</ul>
<br>
This cipher is insecure — but it demonstrates important cryptographic concepts:
<ul>
<li>Reversibility</li>
<li>Byte-wise transformations</li>
<li>Why randomness and key handling matter</li>
</ul>
<p>You’ll build on this when implementing real-world ciphers like ChaCha20 or AES.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tooling-up"><a class="header" href="#tooling-up">Tooling Up</a></h2>
<p>Before we dive deeper into cryptographic primitives, let’s set up our toolbox. In Rust, safety begins before you write code — it starts with choosing the right tools.</p>
<h3 id="compiler-and-toolchain"><a class="header" href="#compiler-and-toolchain">Compiler and Toolchain</a></h3>
<p>Install Rust via rustup</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<br>
Prefer cargo new --lib for cryptographic crates
<p>Enable relevant features in Cargo.toml
Example:</p>
<pre><code class="language-toml">[dependencies]
hex = "0.4"
rand = "0.8"
</code></pre>
<h3 id="linting--formatting"><a class="header" href="#linting--formatting">Linting &amp; Formatting</a></h3>
<p>rustfmt — keep your code idiomatic</p>
<p>clippy — catch logic errors and subtle anti-patterns</p>
<p>Useful alias:</p>
<pre><code class="language-bash">alias checkall="cargo fmt -- --check &amp;&amp; cargo clippy -- -D warnings &amp;&amp; cargo test"
</code></pre>
<h3 id="testing--fuzzing"><a class="header" href="#testing--fuzzing">Testing &amp; Fuzzing</a></h3>
<p>proptest — Generates randomized inputs to test your code against edge cases automatically.</p>
<p>cargo-fuzz — Finds vulnerabilities by feeding random inputs and monitoring for panics or crashes.</p>
<p>Write tests early using #[cfg(test)]</p>
<p>Use property-based testing with proptest:</p>
<pre><code class="language-toml">[dev-dependencies]
proptest = "1.4"
</code></pre>
<p>Fuzzing with cargo-fuzz</p>
<pre><code class="language-bash">cargo install cargo-fuzz
cargo fuzz init
</code></pre>
<h3 id="audit--security-tools"><a class="header" href="#audit--security-tools">Audit &amp; Security Tools</a></h3>
<p>cargo — audit to catch vulnerable dependencies:</p>
<pre><code class="language-bash">cargo install cargo-audit
cargo audit
</code></pre>
<p>Dependency pinning with Cargo.lock</p>
<p>Review unsafe blocks early and often</p>
<h3 id="other-useful-tools"><a class="header" href="#other-useful-tools">Other Useful Tools</a></h3>
<p>criterion.rs — for benchmarking crypto algorithms</p>
<p>cargo-expand — view macro-expanded code</p>
<p>cargo-geiger — scan for unsafe code:</p>
<pre><code class="language-bash">cargo install cargo-geiger
cargo geiger
</code></pre>
<p><br><br>
With the right tools in place, you’re ready to build cryptographic systems that are not only secure — but readable, maintainable, and testable. Let’s move from theory to code.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
